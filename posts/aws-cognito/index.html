<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Software As A Hobby"/><link rel="canonical" href="https://www.softwareasahobby.com/posts/aws-cognito"/><meta name="twitter:url" content="https://www.softwareasahobby.com/posts/aws-cognito"/><meta name="og:url" content="https://www.softwareasahobby.com/posts/aws-cognito"/><title>Cognito | Software As A Hobby</title><meta name="twitter:title" content="Cognito | Software As A Hobby"/><meta name="og:title" content="Cognito | Software As A Hobby"/><meta name="description" content="Cognito to authorize lambda access"/><meta name="twitter:description" content="Cognito to authorize lambda access"/><meta name="og:description" content="Cognito to authorize lambda access"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/StandardTheme/styles.css" type="text/css"/><link rel="stylesheet" href="/StandardTheme/splash_styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Software As A Hobby"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">Software As A Hobby</a></div></header><div class="wrapper"><article><div class="content"><h1>Cognito</h1><h2>Introduction</h2><p>After having setup my lambda previously the next thing I thought would be worth while doing was setting up authentication for it.</p><p>I could be wrong but it seems like the <a href="https://github.com/swift-aws/aws-sdk-swift">sdk</a> I want to use is aimed more at machine-to-machine communication rather than user-to-machine and is probably only meant to be used as a backend technology rather than client facing. Which will be fine for later but not for setting up client communication.</p><p>I found this <a href="https://aws.amazon.com/blogs/mobile/understanding-amazon-cognito-user-pool-oauth-2-0-grants/">article</a> and will attempt to authenticate using the "OAuth 2.0 Authorization Code Grant".</p><p>Rather than building an actual application at this point I will use <a href="https://paw.cloud">Paw HTTP Client</a> to make any relevant api calls.</p><h2>Steps to authorize a request</h2><p>To use the Authorization Code flow with PKCE I need to do the following.</p><ol><li>Configure API Gateway</li><li>Hit the /oauth2/authorize end point to retrieve a redirect to user login where a code can be retrieved</li><li>Hit the /oauth2/token end point to retrieve identity, access and refresh tokens</li><li>Use the access token in your request header to Authorize a request</li></ol><h2>User pool configuration</h2><h3>Resource services</h3><p>Create a new resource and add a scope for use later</p><img src="resource_server.png" alt="Resource servers configuration"/><h3>App client settings</h3><p>Configure an App client</p><p>Enabled identity provider: Cognito User Pool</p><p>ID, Callback and Sign In URLs will be needed later.</p><p>Choose <code>Authoization code grant</code> flow.</p><img src="app_clients.png" alt="App client settings"/><h3>Domain name</h3><p>Choose a domain name this will be where authorization and token requests will be sent.</p><img src="domain_name.png" alt="Domain name"/><h2>Request Authorization</h2><h3>PKCE</h3><p>Before requesting authorization a code challenge and verifier must be created. This helps ensure the source is the same for both authorization and token requests.</p><h4>Generate verifier</h4><pre><code><span class="swift keyword">func</span> generateVerifier() -&gt; <span class="swift type">String</span> {
    <span class="swift keyword">var</span> buffer = [<span class="swift type">UInt8</span>](repeating: <span class="swift number">0</span>, count: <span class="swift number">32</span>)
    <span class="swift keyword">_</span> = <span class="swift type">SecRandomCopyBytes</span>(kSecRandomDefault, buffer.<span class="swift property">count</span>, &amp;buffer)
    <span class="swift keyword">let</span> verifier = <span class="swift type">Data</span>(buffer).<span class="swift call">base64EncodedString</span>()
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"+"</span>, with: <span class="swift string">"-"</span>)
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"/"</span>, with: <span class="swift string">"_"</span>)
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"="</span>, with: <span class="swift string">""</span>)
    .<span class="swift call">trimmingCharacters</span>(in: .<span class="swift dotAccess">whitespaces</span>)
    <span class="swift keyword">return</span> verifier
}
</code></pre><h4>Generate challenge</h4><pre><code><span class="swift keyword">func</span> generateChallenge(verifier: <span class="swift type">String</span>) -&gt; <span class="swift type">String</span>? {
    <span class="swift keyword">guard let</span> data = verifier.<span class="swift call">data</span>(using: .<span class="swift dotAccess">utf8</span>) <span class="swift keyword">else</span> { <span class="swift keyword">return nil</span> }
    <span class="swift keyword">var</span> buffer = [<span class="swift type">UInt8</span>](repeating: <span class="swift number">0</span>,  count: <span class="swift type">Int</span>(<span class="swift type">CC_SHA256_DIGEST_LENGTH</span>))
    data.<span class="swift call">withUnsafeBytes</span> {
    <span class="swift keyword">_</span> = <span class="swift type">CC_SHA256</span>($0, <span class="swift type">CC_LONG</span>(data.<span class="swift property">count</span>), &amp;buffer)
    }
    <span class="swift keyword">let</span> hash = <span class="swift type">Data</span>(buffer)
    <span class="swift keyword">let</span> challenge = hash.<span class="swift call">base64EncodedString</span>()
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"+"</span>, with: <span class="swift string">"-"</span>)
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"/"</span>, with: <span class="swift string">"_"</span>)
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"="</span>, with: <span class="swift string">""</span>)
    .<span class="swift call">trimmingCharacters</span>(in: .<span class="swift dotAccess">whitespaces</span>)
    <span class="swift keyword">return</span> challenge
}
</code></pre><h2>/oauth2/authorize</h2><p>Execute a GET request to the cognito sub domain with required parameters passed in the query string.</p><pre><code><span class="swift comment">// **SUB_DOMAIN**: The sub domain created earlier
// **AWS_REGION**: The aws region used when creating a sub domain
// **CLIENT_ID**: The ID found in App client settings
// **CALL_BACK_URL**: The url specified in App client settings
// **SCOPES**: space seperated scopes. Custom scopes must be defined in resource server and set to allowed in App client settings. A scope name includes ResourceServerIdentifier/ScopeName
// **CODE_CHALLENGE**: PKCE code challenge, this is a hash of the verifier which is itself just random bytes.  All base64 encoded.</span>

<span class="swift type">GET</span> https://&lt;<span class="swift type">SUB_DOMAIN</span>&gt;.auth.&lt;<span class="swift type">AWS_REGION</span>&gt;.amazoncognito.<span class="swift property">com</span>/oauth2/authorize?response_type=code&amp;client_id=&lt;<span class="swift type">CLIENT_ID</span>&gt;&amp;redirect_uri=&lt;<span class="swift type">CALL_BACK_URL</span>&gt;&amp;scope=phone%20openid%<span class="swift number">20</span>&lt;<span class="swift type">SCOPES</span>&gt;&amp;code_challenge_method=<span class="swift type">S256</span>&amp;code_challenge=&lt;<span class="swift type">CODE_CHALLENGE</span>&gt;
</code></pre><p>A successful response will redirect using the <code>Location</code> header</p><h2>/oauth2/token</h2><p>Execute a form post to the sub domain with required parameters passed in the body.</p><pre><code><span class="swift comment">// **BASE64(CLIENT_ID:CLIENT_SECRET)**: Colon seperated client id and secret, base64 encoded found in App client settings.
// **AUTHORIZATION_CODE**: The code found on the redirect after user login.
// **CLIENT_ID**: The ID found in App client settings.
// **CALLBACK_URL**: The url specified in App client settings.
// **CODE_VERIFIER**: PKCE code verifier for the challenge sent previously.  This is the original unhashed random bytes base64 encoded.</span>

<span class="swift type">POST</span> /oauth2/token <span class="swift type">HTTP</span>/<span class="swift number">1.1</span>
<span class="swift type">Authorization</span>: <span class="swift type">Basic</span> &lt;<span class="swift type">BASE64</span>(<span class="swift type">CLIENT_ID</span>:<span class="swift type">CLIENT_SECRET</span>)&gt;
<span class="swift type">Content</span>-<span class="swift type">Type</span>: application/x-www-form-urlencoded

grant_type=authorization_code&amp;code=&lt;<span class="swift type">AUTHORIZATION_CODE</span>&gt;&amp;client_id=&lt;<span class="swift type">CLIENT_ID</span>&gt;&amp;redirect_uri=&lt;<span class="swift type">CALLBACK_URL</span>&gt;&amp;code_verifier=&lt;<span class="swift type">CODE_VERIFIER</span>&gt;
</code></pre><h2>Require authorization to access our lambda</h2><br/><h3>Authorize request using id token (not recommended)</h3><ul><li>Choose the Cognito user pool as your Authorization method</li><li>Do not specify any scopes</li><li>Use <code>id token</code> as <code>Authorization</code> header</li><li>Do not include <code>Bearer</code> in token string.</li></ul><br/><h3>Scopes</h3><p>The following seemed unstable it would work sometimes and then the steps would not work later, I am yet to understand why this is the case. (it is not due to token expiry as I did the entire authorisation process again)</p><ul><li>Choose the Cognito user pool as your Authorization method</li><li>Specify scopes</li><li>Use <code>access token</code> as <code>Authorization</code> header</li><li>Do not include <code>Bearer</code> in token string.</li></ul><h2>Other options</h2><p>The implicit flow is an option in AWS to retrieve an access token however it is not recommended as it is considered that there are a greater number of vulnerabilities in that flow. There is a video <a href="https://oauth.net/2/grant-types/implicit/">here</a> that discusses the topic.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/experiment">experiment</a></li><li><a href="/tags/aws">aws</a></li><li><a href="/tags/lambda">lambda</a></li><li><a href="/tags/api-gateway">api gateway</a></li><li><a href="/tags/cognito">cognito</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>