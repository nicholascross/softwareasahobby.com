<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Software As A Hobby</title><description>A place to throw rocks in a pond.  It might look pointless but it can be fun.</description><link>https://www.softwareasahobby.com</link><language>en</language><lastBuildDate>Thu, 2 Jul 2020 09:12:09 +1000</lastBuildDate><pubDate>Thu, 2 Jul 2020 09:12:09 +1000</pubDate><ttl>250</ttl><atom:link href="https://www.softwareasahobby.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.softwareasahobby.com/posts/aws-cognito</guid><title>Cognito</title><description>Cognito to authorize lambda access</description><link>https://www.softwareasahobby.com/posts/aws-cognito</link><pubDate>Wed, 1 Jul 2020 11:30:00 +1000</pubDate><content:encoded><![CDATA[<h1>Cognito</h1><h2>Introduction</h2><p>After having setup my lambda previously the next thing I thought would be worth while doing was setting up authentication for it.</p><p>I could be wrong but it seems like the <a href="https://github.com/swift-aws/aws-sdk-swift">sdk</a> I want to use is aimed more at machine-to-machine communication rather than user-to-machine and is probably only meant to be used as a backend technology rather than client facing. Which will be fine for later but not for setting up client communication.</p><p>I found this <a href="https://aws.amazon.com/blogs/mobile/understanding-amazon-cognito-user-pool-oauth-2-0-grants/">article</a> and will attempt to authenticate using the "OAuth 2.0 Authorization Code Grant".</p><p>Rather than building an actual application at this point I will use <a href="https://paw.cloud">Paw HTTP Client</a> to make any relevant api calls.</p><h2>Steps to authorize a request</h2><p>To use the Authorization Code flow with PKCE I need to do the following.</p><ol><li>Configure API Gateway</li><li>Hit the /oauth2/authorize end point to retrieve a redirect to user login where a code can be retrieved</li><li>Hit the /oauth2/token end point to retrieve identity, access and refresh tokens</li><li>Use the access token in your request header to Authorize a request</li></ol><h2>User pool configuration</h2><h3>Resource services</h3><p>Create a new resource and add a scope for use later</p><img src="resource_server.png" alt="Resource servers configuration"/><h3>App client settings</h3><p>Configure an App client</p><p>Enabled identity provider: Cognito User Pool</p><p>ID, Callback and Sign In URLs will be needed later.</p><p>Choose <code>Authoization code grant</code> flow.</p><img src="app_clients.png" alt="App client settings"/><h3>Domain name</h3><p>Choose a domain name this will be where authorization and token requests will be sent.</p><img src="domain_name.png" alt="Domain name"/><h2>Request Authorization</h2><h3>PKCE</h3><p>Before requesting authorization a code challenge and verifier must be created. This helps ensure the source is the same for both authorization and token requests.</p><h4>Generate verifier</h4><pre><code><span class="swift keyword">func</span> generateVerifier() -&gt; <span class="swift type">String</span> {
    <span class="swift keyword">var</span> buffer = [<span class="swift type">UInt8</span>](repeating: <span class="swift number">0</span>, count: <span class="swift number">32</span>)
    <span class="swift keyword">_</span> = <span class="swift type">SecRandomCopyBytes</span>(kSecRandomDefault, buffer.<span class="swift property">count</span>, &amp;buffer)
    <span class="swift keyword">let</span> verifier = <span class="swift type">Data</span>(buffer).<span class="swift call">base64EncodedString</span>()
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"+"</span>, with: <span class="swift string">"-"</span>)
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"/"</span>, with: <span class="swift string">"_"</span>)
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"="</span>, with: <span class="swift string">""</span>)
    .<span class="swift call">trimmingCharacters</span>(in: .<span class="swift dotAccess">whitespaces</span>)
    <span class="swift keyword">return</span> verifier
}
</code></pre><h4>Generate challenge</h4><pre><code><span class="swift keyword">func</span> generateChallenge(verifier: <span class="swift type">String</span>) -&gt; <span class="swift type">String</span>? {
    <span class="swift keyword">guard let</span> data = verifier.<span class="swift call">data</span>(using: .<span class="swift dotAccess">utf8</span>) <span class="swift keyword">else</span> { <span class="swift keyword">return nil</span> }
    <span class="swift keyword">var</span> buffer = [<span class="swift type">UInt8</span>](repeating: <span class="swift number">0</span>,  count: <span class="swift type">Int</span>(<span class="swift type">CC_SHA256_DIGEST_LENGTH</span>))
    data.<span class="swift call">withUnsafeBytes</span> {
    <span class="swift keyword">_</span> = <span class="swift type">CC_SHA256</span>($0, <span class="swift type">CC_LONG</span>(data.<span class="swift property">count</span>), &amp;buffer)
    }
    <span class="swift keyword">let</span> hash = <span class="swift type">Data</span>(buffer)
    <span class="swift keyword">let</span> challenge = hash.<span class="swift call">base64EncodedString</span>()
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"+"</span>, with: <span class="swift string">"-"</span>)
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"/"</span>, with: <span class="swift string">"_"</span>)
    .<span class="swift call">replacingOccurrences</span>(of: <span class="swift string">"="</span>, with: <span class="swift string">""</span>)
    .<span class="swift call">trimmingCharacters</span>(in: .<span class="swift dotAccess">whitespaces</span>)
    <span class="swift keyword">return</span> challenge
}
</code></pre><h2>/oauth2/authorize</h2><p>Execute a GET request to the cognito sub domain with required parameters passed in the query string.</p><pre><code><span class="swift comment">// **SUB_DOMAIN**: The sub domain created earlier
// **AWS_REGION**: The aws region used when creating a sub domain
// **CLIENT_ID**: The ID found in App client settings
// **CALL_BACK_URL**: The url specified in App client settings
// **SCOPES**: space seperated scopes. Custom scopes must be defined in resource server and set to allowed in App client settings. A scope name includes ResourceServerIdentifier/ScopeName
// **CODE_CHALLENGE**: PKCE code challenge, this is a hash of the verifier which is itself just random bytes.  All base64 encoded.</span>

<span class="swift type">GET</span> https://&lt;<span class="swift type">SUB_DOMAIN</span>&gt;.auth.&lt;<span class="swift type">AWS_REGION</span>&gt;.amazoncognito.<span class="swift property">com</span>/oauth2/authorize?response_type=code&amp;client_id=&lt;<span class="swift type">CLIENT_ID</span>&gt;&amp;redirect_uri=&lt;<span class="swift type">CALL_BACK_URL</span>&gt;&amp;scope=phone%20openid%<span class="swift number">20</span>&lt;<span class="swift type">SCOPES</span>&gt;&amp;code_challenge_method=<span class="swift type">S256</span>&amp;code_challenge=&lt;<span class="swift type">CODE_CHALLENGE</span>&gt;
</code></pre><p>A successful response will redirect using the <code>Location</code> header</p><h2>/oauth2/token</h2><p>Execute a form post to the sub domain with required parameters passed in the body.</p><pre><code><span class="swift comment">// **BASE64(CLIENT_ID:CLIENT_SECRET)**: Colon seperated client id and secret, base64 encoded found in App client settings.
// **AUTHORIZATION_CODE**: The code found on the redirect after user login.
// **CLIENT_ID**: The ID found in App client settings.
// **CALLBACK_URL**: The url specified in App client settings.
// **CODE_VERIFIER**: PKCE code verifier for the challenge sent previously.  This is the original unhashed random bytes base64 encoded.</span>

<span class="swift type">POST</span> /oauth2/token <span class="swift type">HTTP</span>/<span class="swift number">1.1</span>
<span class="swift type">Authorization</span>: <span class="swift type">Basic</span> &lt;<span class="swift type">BASE64</span>(<span class="swift type">CLIENT_ID</span>:<span class="swift type">CLIENT_SECRET</span>)&gt;
<span class="swift type">Content</span>-<span class="swift type">Type</span>: application/x-www-form-urlencoded

grant_type=authorization_code&amp;code=&lt;<span class="swift type">AUTHORIZATION_CODE</span>&gt;&amp;client_id=&lt;<span class="swift type">CLIENT_ID</span>&gt;&amp;redirect_uri=&lt;<span class="swift type">CALLBACK_URL</span>&gt;&amp;code_verifier=&lt;<span class="swift type">CODE_VERIFIER</span>&gt;
</code></pre><h2>Require authorization to access our lambda</h2><br/><h3>Authorize request using id token (not recommended)</h3><ul><li>Choose the Cognito user pool as your Authorization method</li><li>Do not specify any scopes</li><li>Use <code>id token</code> as <code>Authorization</code> header</li><li>Do not include <code>Bearer</code> in token string.</li></ul><br/><h3>Scopes</h3><p>The following seemed unstable it would work sometimes and then the steps would not work later, I am yet to understand why this is the case. (it is not due to token expiry as I did the entire authorisation process again)</p><ul><li>Choose the Cognito user pool as your Authorization method</li><li>Specify scopes</li><li>Use <code>access token</code> as <code>Authorization</code> header</li><li>Do not include <code>Bearer</code> in token string.</li></ul><h2>Other options</h2><p>The implicit flow is an option in AWS to retrieve an access token however it is not recommended as it is considered that there are a greater number of vulnerabilities in that flow. There is a video <a href="https://oauth.net/2/grant-types/implicit/">here</a> that discusses the topic.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.softwareasahobby.com/posts/swift-aws-lambda</guid><title>Swift AWS Lambda runtime</title><description>How to configure swift aws lambda runtime</description><link>https://www.softwareasahobby.com/posts/swift-aws-lambda</link><pubDate>Mon, 8 Jun 2020 16:37:00 +1000</pubDate><content:encoded><![CDATA[<h1>Swift AWS Lambda runtime</h1><h2>Introduction</h2><p>The <a href="https://github.com/swift-server/swift-aws-lambda-runtime/">swift aws lambda runtime</a> project came up in my github activity as someone I follow starred the project.</p><p>The possibility to create lambdas in swift is intrigueing as we are using AWS Lambda to support the iOS app my team and I are building for my day job.</p><p>AWS doesn't support this runtime directly but they do support custom runtimes and this is a community driven project with support of the <a href="https://swift.org/blog/aws-lambda-runtime/">swift core team</a></p><p>I am not sure how easily interaction would be with other parts of the AWS ecosystem but I recently came across this project <a href="https://github.com/swift-aws/aws-sdk-swift">aws-sdk-swift</a> which perhaps might be of some help with future parts of this project.</p><p>As someone who was completely niave and with no previous AWS experience I thought it might be useful to document my experience of getting this up and running.</p><p><em>The following will likely not be an example of minimum approach and as I have no training on any part of AWS it will potentially also not be an example of best practices</em></p><h2>Create an AWS account</h2><p>This was all fairly straight forward and doesn't warrant documenting.</p><p>To get started go to <a href="https://aws.amazon.com">AWS website</a>.</p><p>From there sign up and get access to 12 months free tier. The thing I found slightly worrying was that as someone who wanted to just experiment with AWS not run a mission cirtical website there appears to be no way put a cap on expenditure. This seems to be an intentional oversight on the part of AWS with the justification being that a normal business would not want a hard cut off, but as an individual just learning AWS the thought of racking up a huge bill seems worrisome.</p><h2>Create a simple lambda</h2><p>For the purposes of testing I thought it would be helpful to have a simple lambda for testing.</p><img src="first_lambda.png" alt="First lambda for testing"/><p>From Services menu in AWS find "Lambda" and click create function. I chose Node.js as the Runtime for now but you can see options for "Custom Runtime" which I assume is what I will use later when I switch to swift.</p><img src="choose_runtime.png" alt="Choose runtime"/><p>A hello world style function should be created that will return a 200 response with a simple message anytime it is triggered.</p><h2>Configure API Gateway</h2><h3>Create a REST API</h3><p>From Services choose "API Gateway" and then click "Create API".</p><p>You can create different APIs I chose "REST API".</p><p>Once the API is created, I navigated to "Resources" where from the "Actions" dropdown I chose "Create Resource".</p><img src="create_resource.png" alt="Create resource"/><p>With the newly created Resource selected choose "Create Method". The integration type will obviously be "Lambda Function".</p><p>In the Lambda Function text field type the name of the Lambda, it should auto complete and click "Save".</p><h3>Create an API key</h3><p>I thought it wise to create an API key to somewhat restrict calls to the API.</p><p>This can be done under "API Keys", from "Actions" dropdown choose "Create API key", choose a name and allow AWS to auto generate a key.</p><h3>Create a Usage Plan</h3><p>To set limits on a specific API Key a usage plan must be created. From "Usage Plans" click "Create".</p><p>I chose a very low "Rate", "Burst" and "Quota" as I am more concerned with restricting accidental misuse or abuse rather than fullfilment.</p><h3>Create Stage for deployment</h3><p>Before you can create a stage you need deploy the lambda. From "Resource" select "Deploy API" from "Actions" dropdown.</p><p>From Stages choose "Create" and specify a name for the stage and choose the deployment from the dropdown.</p><h3>Assocate API Key</h3><p>From "Usage Plans" select the plan created previously and then click "Add API Stage".</p><p>Choose the API and stage.</p><p>Additionally the Resource Method must specify "API Key Request" as <code>true</code>. I am not sure if this is the best way but I did this from Resources, by selecting the Method.</p><img src="require_api_key.png" alt="Require API Key"/><h2>Setting up a custom domain</h2><p>I decided to use a subdomain for a domain I already own. With very limited knowledge of name server configuration this proved slightly challenging but here is the steps I followed.</p><h3>Create an SSL certificate</h3><p>All traffic must be encrypted using HTTPS a certificate needs to be created or provided. I chose to create a new one for my specific sub domain using AWS Certificate Manager.</p><p>To get the certificate issued you have to validate that you are the owner of the domain as I do not have admin or webmaster email addresses set up for the domain in question I had to use DNS record approach for this.</p><p>To do this I had to specify a new CNAME record, it is important to note that the CNAME record was not just for the particular subdomain but there was an additional "random" string of characters to be specified as well. This can be found under the name column.</p><h3>Create a custom domain</h3><p>Back under API Gateway service select "Custom domain names" and click "Create".</p><p>I specified my subdomain and as I intend to only use this from a single region I chose "Regional" end point type.</p><p>Choose the certificate created previously in AWS Certificate Manager and click "Create".</p><p>Next click "Configure API Mappings" and add a new mapping for the API and Stage.</p><h3>Delegate subdomain authority</h3><p>As my domain is hosted outside of AWS I had to delegate authority for the subdomain to AWS Route53 service.</p><ol><li>Create new hosted zone in Route53.</li><li>Create new NS records in the register of my domain outside of AWS. Each NS record is for the subdomain and should have the value of the name servers specified in Route53 for the domain.</li><li>The SOA record in Route53 indicates that responsibility for this sub domain will be managed from there.</li><li>In Route53 add a new record set for the subdomain of type <code>A</code></li><li>Choose "Alias" <code>Yes</code> radio option</li><li>Specify the alias target to be the API gateway</li></ol><h2>Using Swift Lambda runtime</h2><h3>Prerequisites</h3><ol><li>Install <a href="https://www.docker.com/products/docker-desktop">Docker</a></li><li>Install <a href="https://stedolan.github.io/jq/download/">jq</a></li><li>Install <a href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html">aws cli</a></li><li><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html">Create IAM Admin user</a></li><li><a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html">Configure aws cli</a></li></ol><h3>Deploying hello world swift lambda</h3><ol><li>Create a new s3 bucket <code>swift-lambda-test</code> which is used during the deployment process</li><li>Create a new lambda named <code>HelloSwift</code> with a custom runtime</li><li>Expose the the lambda through the API Gateway Service</li><li>Enforce API Key restrictions</li><li>Next clone <code>git@github.com:swift-server/swift-aws-lambda-runtime.git</code></li><li>Modify <code>deploy.sh</code> in the examples <code>scripts</code><ul><li>change <code>lambda_name</code> value to <code>HelloSwift</code>.</li></ul></li></ol><ol start="7"><li>run <code>./scripts/deploy.sh</code></li><li>Deploy the newly updated API to your Stage in API Gateway</li></ol><p>Done. 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.softwareasahobby.com/posts/website-purpose</guid><title>What to expect from this site?</title><description>Initial commit</description><link>https://www.softwareasahobby.com/posts/website-purpose</link><pubDate>Mon, 8 Jun 2020 16:37:00 +1000</pubDate><content:encoded><![CDATA[<h1>What to expect from this site?</h1><p>This site is fundementally a dumping ground for any software development experiments I do outside of work.</p><h2>Why create this site?</h2><p>I like to do a lot of small experiments and play with different related technologies. Most often this is because I want to learn more about a particular concept but it might also just be because I am interested to see what can be done and enjoy the challenge of working with new things.</p><p>I have heard it said that if you want to learn something then try teaching it. So with that thought in mind it seemed practical to create a website where I could layout out some of the different things I have been messing around with recently and try to explain them for others.</p><p>Even so this site is not intended to be place for great writing and easy to follow tutorials, so don't be disappointed when it falls short of that.</p><h2>Who is it for?</h2><p>I would be happy if any others find any of this content useful but primarily this site is for myself. Stating this up front allows me to focus building things rather than perfecting blog posts.</p><h2>When will this site be updated?</h2><p>This site will likely not see many updates as my main priority is to explore and have fun building things.</p><h2>How am I building this site?</h2><p>This site built using a static site generator called <a href="https://github.com/JohnSundell/Publish">Publish</a> which was written in Swift and open sourced by John Sundell. It would probably be good to write an article about it once I figure out how to use it properly.</p><p>🖖</p>]]></content:encoded></item></channel></rss>